16  上午学习git  github  以及预习
    下午  复习bootstrap juqery   考试（布局）
17   整理angular内容 复习angular
18   自行定义项目   要求（月考要求）
	1 有服务
	2 有json
	3 http服务请求数据
 	4 路由
	5 控制器
	6 路由渲染
	7 注释
19      预习拦截器
        预习过滤器
	动画实现


git  init 				实例化启动git
git  remote add origin “地址”		添加远程地址
git  remote -v   			查看
git  add . 				将工作区放到缓存区
git  commit -m "描述"			将缓存区放到本地仓库区
git  pull origin master 		dang代码
git  push -u origin master 		提交代码


作业  五遍

gulp-uglify （JS压缩）
gulp-minify-css（CSS压缩）
gulp-minify-html（html压缩）
gulp-jshint（JS代码检查）
gulp-concat（文件合并）
gulp-less（编译Less）
gulp-sass（编译Sass）
gulp-imagemin（压缩图片）
angular中变量是双向绑定的 ，那么怎么知道一个变量是否是变化了呢？

1能通过固定的接口才能改变变量的值，比如说只能通过set()设置变量的值，set被调用的时候比较一下就知道了。这种方法的缺点是写法比较繁琐。
2脏检查，将原对象复制一份快照，在某个时间，比较现在对象与快照的值，如果不一样就表明发生了变化，这个策略要保留两份变量，而且要遍历对象，比较每个属性，这样会有一定的性能问题

angular使用的就是脏检查：
1不会脏检查所有的对象。当对象被绑定到html中后，这个对象才会添加为检查对象（watcher）
2不会脏检查所有的属性，同样当属性被绑定后，这个属性才会被列为检查的属性
在angular程序初始化时，会将绑定的对象的属性添加为监听对象（watcher），也就是说一个对象绑定了N个属性，就会添加N个watcher。


controller先运行，compile后运行，link不运行(link就是compile中的postLink)。
controller先运行，link后运行，link和compile不兼容。compile改变dom,link事件的触发和绑定

控制器之间的通讯

1, 利用作用域的继承方式

由于作用域的继承是基于js的原型继承方式，所以这里分为两种情况，当作用域上面的值为基本类型的时候，修改父作用域上面的值会 影响到子作用域，反之，修改子作用域只会影响子作用域的值，不会影响父作用域上面的值；如果需要父作用域与子作用域共享一个值 的话，就需要用到后面一种，即作用域上的值为对象，任何一方的修改都能影响另一方，这是因为在js中对象都是引用类型。

2, 基于事件的方式

在一般情况下基于继承的方式已经足够满足大部分情况了，但是这种方式没有实现兄弟控制器之间的通信方式，所以引出了事件的方式 。基于事件的方式中我们可以里面作用的$on,$emit,$boardcast这几个方式来实现，其中$on表示事件监听，$emit表示向父级以上的 作用域触发事件， $boardcast表示向子级以下的作用域广播事件。
从这个用法我们可以引申出一种用于兄弟控制间进行通信的方法，首先我们一个兄弟控制中向父作用域触发一个事件，然后在父作用域 中监听事件，再广播给子作用域，这样通过事件携带的参数，实现了数据经过父作用域，在兄弟作用域之间传播。这里要注意的是，通过父元素作为中介进行传递的话，兄弟元素用的事件名不能一样，否则会进入死循环。请看代码：

3, angular服务的方式

在ng中服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。参照以下例子，在一个控制器修改了服务对象的值，

兄弟作用域之间传播

